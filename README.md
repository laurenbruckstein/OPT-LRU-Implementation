# OPT-LRU-Implementation

Project overview
----------------

In class, we have discussed various page replacement algorithms that an Operating System implementer may choose to use. We have also discussed local and global page replacement policies. In particular, in local page replacement, each process is allocated a certain number of physical memory frames, and when a page is to be evicted, the victim page is selected among the pages of the same process. In this project, you will simulate the **Least Recently Used (LRU)** and **Optimal (OPT)** replacement algorithms by reading traces of memory references that were generated by two processes while running on a 32-bit system and collecting relevant metrics.  Because it is local page replacement algorithm, each process has its own frames (i.e., a percentage of the total available physical memory). While simulating the algorithm, you will collect statistics about its performance, such as the number of page faults that occur and the number of dirty frames that had to be written back to disk. When you are done with your program, you will write up your results and provide a graph that compares the performance of the two algorithms under various ways to split physical memory up between the two processes. The page size, the total number of frames, and the memory split will be command-line arguments to the execution of your program.

_You may write your program in C/C++, Java, Perl, or Python as long as it runs on thoth.cs.pitt.edu with the “./vsim” command specified below._


Project Details
---------------

Your virtual memory simulator, called vmsim, takes the following command line arguments:
```shell
./vmsim -a <opt|lru> –n <numframes> -p <pagesize in KB> -s <memory split> <tracefile>
```
The memory split between the two processes is provided in the form a:b, where a and b are positive integers > 0 that represent the ratios of each process's memory allocation. For example, a 1:2 split means that the second process gets twice as many frames as the first process (i.e., the first process gets one third and the second two thirds). The sum of a and b evenly divided the total number of frames.

The program/simulator will run through the memory references of the trace file and decide the action taken for each address (memory hit, page fault with no eviction, page fault and evict clean page, page fault and evict dirty page).
When the trace is over (that is, after dealing with all the memory references for both simulated processes), `vmsim` prints out summary statistics **in the following format (as you know, Gradescope grading requires very strict formatting)**:
```
Algorithm: LRU
Number of frames: 8
Page size: 8 KB
Total memory accesses: %d
Total page faults: %d
Total writes to disk: %d
```
